<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shear Force Visualization (Adjustable Arrows)</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin-top: 20px; }
        #controls { margin-bottom: 10px; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 15px; }
        .control-group { display: flex; align-items: center; gap: 5px; }
        canvas { border: 1px solid black; image-rendering: pixelated; width: 480px; height: 480px; }
        #status { margin-top: 10px; font-style: italic; }
        input[type="number"] { width: 70px; }
        input[type="range"] { width: 120px; }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <button id="connectButton">Connect</button>
        </div>
        <div class="control-group">
            <label for="baudRateInput">Baud Rate:</label>
            <input type="number" id="baudRateInput" value="12000000">
        </div>
        <div class="control-group">
            <label for="thresholdSlider">Threshold:</label>
            <input type="range" id="thresholdSlider" min="0" max="200" value="60">
            <span id="thresholdValue">60</span>
        </div>
         <div class="control-group">
            <label for="scaleSlider">Arrow Scale:</label>
            <input type="range" id="scaleSlider" min="0.1" max="2.0" step="0.1" value="0.8">
            <span id="scaleValue">0.8</span>
        </div>
         <div class="control-group">
            <label for="thicknessSlider">Arrow Thickness:</label>
            <input type="range" id="thicknessSlider" min="1" max="10" step="1" value="3">
            <span id="thicknessValue">3</span>
        </div>
    </div>

    <canvas id="visualizationCanvas"></canvas>
    <div id="status">Status: Disconnected</div>

    <script>
        const connectButton = document.getElementById('connectButton');
        const baudRateInput = document.getElementById('baudRateInput');
        const statusDiv = document.getElementById('status');
        const canvas = document.getElementById('visualizationCanvas');
        const ctx = canvas.getContext('2d');

        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValueSpan = document.getElementById('thresholdValue');
        const scaleSlider = document.getElementById('scaleSlider');
        const scaleValueSpan = document.getElementById('scaleValue');
        const thicknessSlider = document.getElementById('thicknessSlider');
        const thicknessValueSpan = document.getElementById('thicknessValue');

        const N = 1024;
        const IMG_DIM = 32;
        const SUPER_PIXEL_DIM = 16;
        const PIXEL_SCALE = 15; // Scale for display (480/32)

        canvas.width = IMG_DIM * PIXEL_SCALE;
        canvas.height = IMG_DIM * PIXEL_SCALE;

        let port;
        let reader;
        let keepReading = false;
        let lineBuffer = '';

        // Control variables
        let threshold = parseInt(thresholdSlider.value);
        let arrowScaleFactor = parseFloat(scaleSlider.value);
        let arrowThickness = parseInt(thicknessSlider.value);

        // Event Listeners for new sliders
        thresholdSlider.addEventListener('input', (event) => {
            threshold = parseInt(event.target.value);
            thresholdValueSpan.textContent = threshold;
        });

        scaleSlider.addEventListener('input', (event) => {
            arrowScaleFactor = parseFloat(event.target.value);
            scaleValueSpan.textContent = arrowScaleFactor.toFixed(1);
        });

        thicknessSlider.addEventListener('input', (event) => {
            arrowThickness = parseInt(event.target.value);
            thicknessValueSpan.textContent = arrowThickness;
        });


        function getColor(value, min = 0, max = 300) {
            if (value < min) value = min;
            if (value > max) max = value; // Auto-scale max
            const normalized = (value - min) / (max - min || 1);
            const hue = (1 - normalized) * 240; // blue to red
            return `hsl(${hue}, 100%, 50%)`;
        }

        function draw(imgDisp, Fx, Fy) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Draw Heatmap
            let maxVal = 300;
            for (let r = 0; r < IMG_DIM; r++) {
                for (let c = 0; c < IMG_DIM; c++) {
                    const value = imgDisp[r][c];
                    if (value > maxVal) maxVal = value;
                    ctx.fillStyle = getColor(value, 0, maxVal);
                    ctx.fillRect(c * PIXEL_SCALE, r * PIXEL_SCALE, PIXEL_SCALE, PIXEL_SCALE);
                }
            }

            // 2. Calculate vector magnitudes and normalize
            const mag = new Array(SUPER_PIXEL_DIM).fill(0).map(() => new Array(SUPER_PIXEL_DIM).fill(0));
            let mmax = 0;
            for (let i = 0; i < SUPER_PIXEL_DIM; i++) {
                for (let j = 0; j < SUPER_PIXEL_DIM; j++) {
                    mag[i][j] = Math.sqrt(Fx[i][j]**2 + Fy[i][j]**2);
                    if (mag[i][j] > mmax) {
                        mmax = mag[i][j];
                    }
                }
            }

            const scaleFx = new Array(SUPER_PIXEL_DIM).fill(0).map(() => new Array(SUPER_PIXEL_DIM).fill(0));
            const scaleFy = new Array(SUPER_PIXEL_DIM).fill(0).map(() => new Array(SUPER_PIXEL_DIM).fill(0));
            if (mmax > 0) {
                for (let i = 0; i < SUPER_PIXEL_DIM; i++) {
                    for (let j = 0; j < SUPER_PIXEL_DIM; j++) {
                        scaleFx[i][j] = Fx[i][j] / mmax;
                        scaleFy[i][j] = Fy[i][j] / mmax;
                    }
                }
            }

            // 3. Draw Arrows (Quiver) using dynamic values
            ctx.strokeStyle = 'white';
            ctx.lineWidth = arrowThickness; // Use variable for thickness
            const arrowScale = arrowScaleFactor * (2 * PIXEL_SCALE); // Use variable for scale

            for (let i = 0; i < SUPER_PIXEL_DIM; i++) {
                for (let j = 0; j < SUPER_PIXEL_DIM; j++) {
                    const startX = (2 * j + 1) * PIXEL_SCALE;
                    const startY = (2 * i + 1) * PIXEL_SCALE;

                    const dx = scaleFx[i][j] * arrowScale;
                    const dy = scaleFy[i][j] * arrowScale;
                    
                    if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) continue;

                    const endX = startX + dx;
                    const endY = startY + dy;

                    // Draw line
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();

                    // Draw arrowhead
                    const angle = Math.atan2(dy, dx);
                    const headlen = 2.5 * arrowThickness; // Make arrowhead size proportional to thickness
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY - headlen * Math.sin(angle - Math.PI / 6));
                    ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY - headlen * Math.sin(angle + Math.PI / 6));
                    ctx.closePath();
                    ctx.fillStyle = 'white';
                    ctx.fill();
                }
            }
        }

        async function connectSerial() {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: parseInt(baudRateInput.value) });
                statusDiv.textContent = 'Connected. Waiting for data...';
                connectButton.textContent = 'Disconnect';
                baudRateInput.disabled = true;
                keepReading = true;
                readLoop();
            } catch (error) {
                statusDiv.textContent = 'Error: ' + error.message;
            }
        }

        async function disconnectSerial() {
            keepReading = false;
            if (reader) {
                await reader.cancel();
            }
            if (port) {
                await port.close();
            }
            port = null;
            reader = null;
            statusDiv.textContent = 'Status: Disconnected';
            connectButton.textContent = 'Connect';
            baudRateInput.disabled = false;
        }

        async function readLoop() {
            if (!port || !port.readable) return;
            const textDecoder = new TextDecoderStream();
            const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
            reader = textDecoder.readable.getReader();

            try {
                while (keepReading) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    lineBuffer += value;
                    let newlineIndex;
                    while ((newlineIndex = lineBuffer.indexOf('\n')) >= 0) {
                        const line = lineBuffer.substring(0, newlineIndex).trim();
                        lineBuffer = lineBuffer.substring(newlineIndex + 1);
                        if (line) {
                           statusDiv.textContent = 'Status: Receiving data...';
                           processData(line);
                        }
                    }
                }
            } catch (error) {
                if (keepReading) {
                    statusDiv.textContent = 'Error reading: ' + error.message;
                }
            } finally {
                reader.releaseLock();
                if (keepReading) {
                    await disconnectSerial();
                }
            }
        }

        function processData(line) {
            const input = line.split(',');
            if (input.length < N) return;

            const vals = input.slice(0, N).map(s => parseFloat(s.trim()));
            if (vals.some(isNaN)) return;

            let img = [];
            for (let i = 0; i < IMG_DIM; i++) {
                img.push(vals.slice(i * IMG_DIM, (i + 1) * IMG_DIM));
            }

            for (let r = 0; r < IMG_DIM; r++) {
                for (let c = 0; c < IMG_DIM; c++) {
                    if (img[r][c] < threshold) {
                        const hasNeighbor = (r > 0 && img[r - 1][c] >= threshold) ||
                                          (r < IMG_DIM - 1 && img[r + 1][c] >= threshold) ||
                                          (c > 0 && img[r][c - 1] >= threshold) ||
                                          (c < IMG_DIM - 1 && img[r][c + 1] >= threshold);
                        if (!hasNeighbor) {
                            img[r][c] = 0;
                        }
                    }
                }
            }
            
            const imgDisp = img;
            imgDisp.reverse();

            const Fx = new Array(SUPER_PIXEL_DIM).fill(0).map(() => new Array(SUPER_PIXEL_DIM).fill(0));
            const Fy = new Array(SUPER_PIXEL_DIM).fill(0).map(() => new Array(SUPER_PIXEL_DIM).fill(0));

            for (let i = 0; i < SUPER_PIXEL_DIM; i++) {
                const rStart = 2 * i;
                for (let j = 0; j < SUPER_PIXEL_DIM; j++) {
                    const cStart = 2 * j;
                    const p = [
                        [imgDisp[rStart][cStart], imgDisp[rStart][cStart + 1]],
                        [imgDisp[rStart + 1][cStart], imgDisp[rStart + 1][cStart + 1]]
                    ];

                    const left = p[0][0] + p[1][0];
                    const right = p[0][1] + p[1][1];
                    const top = p[0][0] + p[0][1];
                    const bottom = p[1][0] + p[1][1];
                    
                    Fx[i][j] = right - left;
                    Fy[i][j] = -top + bottom;
                }
            }
            
            draw(imgDisp, Fx, Fy);
        }

        connectButton.addEventListener('click', () => {
            if (port) {
                disconnectSerial();
            } else {
                connectSerial();
            }
        });

        // Initial empty canvas draw
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = "20px Arial";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.fillText("Connect to device to start visualization", canvas.width/2, canvas.height/2);

        if (!("serial" in navigator)) {
            statusDiv.innerHTML = "<b>Web Serial API not supported.</b> Please use a compatible browser like Chrome or Edge.";
            connectButton.disabled = true;
            baudRateInput.disabled = true;
            thresholdSlider.disabled = true;
            scaleSlider.disabled = true;
            thicknessSlider.disabled = true;
        }
    </script>
</body>
</html>