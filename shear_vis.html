<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Shear Force Visualizer — 32×32 (Web Serial)</title>
  <style>
    :root {
      --pad: 14px;
    }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; padding: var(--pad); display: grid; gap: var(--pad); place-items: start center; background: #0b0c10; color: #e6edf3; }
    header { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center; }
    header > * { margin: 0; }
    .panel { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; background: #111318; border: 1px solid #22252b; padding: 8px 10px; border-radius: 12px; box-shadow: 0 10px 24px rgba(0,0,0,.25) inset; }
    label { opacity: .9; font-size: 14px; }
    input[type="number"] { width: 90px; padding: 6px 8px; border-radius: 10px; border: 1px solid #2a2f39; background: #0f1217; color: #e6edf3; }
    input[type="range"] { width: 140px; }
    button { appearance: none; border: none; background: #2e7dff; color: white; padding: 8px 12px; border-radius: 12px; font-weight: 600; cursor: pointer; }
    button[disabled] { opacity: .5; cursor: not-allowed; }
    #wrap { display: grid; grid-template-columns: auto; gap: 12px; }
    #stage { position: relative; }
    canvas { border: 1px solid #2a2f39; image-rendering: pixelated; background: #0f1217; border-radius: 10px; }
    #heatmap { width: 512px; height: 512px; }
    #status { font-style: italic; opacity: .9; }
    .legend { font-size: 12px; opacity: .85; }
  </style>
</head>
<body>
  <header>
    <div class="panel">
      <button id="connectBtn">Connect</button>
      <label>Baud
        <input type="number" id="baud" value="12000000" />
      </label>
      <span id="status">Status: Disconnected</span>
    </div>
    <div class="panel">
      <label>Threshold
        <input type="number" id="thres" value="60" />
      </label>
      <label>Arrow scale
        <input type="range" id="arrowScale" min="0" max="2" step="0.05" value="0.8" />
        <span class="legend" id="arrowScaleVal">0.80×</span>
      </label>
    </div>
    <div class="panel">
      <label>Clamp max
        <input type="number" id="clampMax" value="300" />
      </label>
      <span class="legend">Heat values auto-clamped to max(Clamp, current max)</span>
    </div>
  </header>

  <div id="wrap">
    <div id="stage">
      <canvas id="heatmap" width="32" height="32"></canvas>
    </div>
  </div>

  <script>
    // ==== Config / DOM ====
    const IMG_DIM = 32;               // 32x32
    const N = IMG_DIM * IMG_DIM;      // 1024

    const heat = document.getElementById('heatmap');
    const hctx = heat.getContext('2d');

    const connectBtn = document.getElementById('connectBtn');
    const baudInput = document.getElementById('baud');
    const statusEl = document.getElementById('status');
    const thresInput = document.getElementById('thres');
    const clampMaxInput = document.getElementById('clampMax');
    const arrowScaleInput = document.getElementById('arrowScale');
    const arrowScaleVal = document.getElementById('arrowScaleVal');

    // Internal state
    let port = null, reader = null; let keepReading = false;
    let img = new Float32Array(N);           // latest 32x32 (pre-rotation)
    let imgDisp = new Float32Array(N);       // rotated + thresholded for display

    // ==== Utility ====
    function lerp(a,b,t){return a+(b-a)*t}

    function getColorTurbo(v, vmin, vmax) { // Fast-ish Turbo-like
      // normalize 0..1
      v = Math.min(vmax, Math.max(vmin, v));
      const x = (vmax === vmin) ? 0 : (v - vmin) / (vmax - vmin);
      // Polynomial approximation of Turbo (simplified)
      const r = Math.round(255 * Math.min(1, Math.max(0, 1.0 + 0.5*Math.cos(6.28318*(x+0.75)))));
      const g = Math.round(255 * Math.min(1, Math.max(0, 1.0 + 0.5*Math.cos(6.28318*(x+0.50)))));
      const b = Math.round(255 * Math.min(1, Math.max(0, 1.0 + 0.5*Math.cos(6.28318*(x+0.25)))));
      return `rgb(${r},${g},${b})`;
    }

    function drawHeatAndVectors() {
      const th = Number(thresInput.value)||0;
      const clampFloor = 0;
      let clampCeil = Number(clampMaxInput.value)||300;

      // 1) Neighbor-aware threshold on original img
      // Copy to work buffer
      const tmp = new Float32Array(img);
      // 4-neighbor check
      for (let r=0; r<IMG_DIM; r++) {
        for (let c=0; c<IMG_DIM; c++) {
          const idx = r*IMG_DIM + c;
          const val = tmp[idx];
          if (val < th) {
            const up    = (r>0  ) ? tmp[(r-1)*IMG_DIM + c] : -Infinity;
            const down  = (r<31 ) ? tmp[(r+1)*IMG_DIM + c] : -Infinity;
            const left  = (c>0  ) ? tmp[r*IMG_DIM + (c-1)] : -Infinity;
            const right = (c<31 ) ? tmp[r*IMG_DIM + (c+1)] : -Infinity;
            if (!(up>=th || down>=th || left>=th || right>=th)) {
              tmp[idx] = 0;
            }
          }
        }
      }

      // 2) Rotate CCW (same as rot90(img,1) in MATLAB)
      // y' = x ; x' = (n-1 - y)
      for (let r=0; r<IMG_DIM; r++) {
        for (let c=0; c<IMG_DIM; c++) {
          const srcIdx = r*IMG_DIM + c;
          const rp = c;
          const cp = 31 - r;
          imgDisp[rp*IMG_DIM + cp] = tmp[srcIdx];
        }
      }

      // pick dynamic color max = max( clampMax, max(imgDisp) )
      let maxVal = 0;
      for (let i=0;i<N;i++) if (imgDisp[i] > maxVal) maxVal = imgDisp[i];
      const vMax = Math.max(clampCeil, maxVal);

      // 3) Draw heatmap pixels
      const imgData = hctx.getImageData(0,0,IMG_DIM,IMG_DIM);
      const data = imgData.data;
      for (let r=0; r<IMG_DIM; r++) {
        for (let c=0; c<IMG_DIM; c++) {
          const v = imgDisp[r*IMG_DIM + c];
          // simple grey for zero
          let R, G, B;
          if (v<=0) { R=20; G=24; B=28; }
          else {
            // map using custom palette
            const col = getColorTurbo(v, 0, vMax);
            // parse rgb(...)
            const [rr,gg,bb] = col.match(/\d+/g).map(Number);
            R=rr; G=gg; B=bb;
          }
          const idx = (r*IMG_DIM + c)*4;
          data[idx+0]=R; data[idx+1]=G; data[idx+2]=B; data[idx+3]=255;
        }
      }
      hctx.putImageData(imgData,0,0);

      // upscale handled by CSS (image-rendering: pixelated)

      // 4) Compute 2x2 block vectors on imgDisp
      const FX = new Float32Array(16*16);
      const FY = new Float32Array(16*16);
      let mmax = 0;
      for (let bi=0; bi<16; bi++) {
        const r0 = bi*2;
        for (let bj=0; bj<16; bj++) {
          const c0 = bj*2;
          const p00 = imgDisp[r0*IMG_DIM + c0];
          const p01 = imgDisp[r0*IMG_DIM + c0+1];
          const p10 = imgDisp[(r0+1)*IMG_DIM + c0];
          const p11 = imgDisp[(r0+1)*IMG_DIM + c0+1];
          const left = p00 + p10;
          const right = p01 + p11;
          const top = p00 + p01;
          const bottom = p10 + p11;
          const fx = right - left;
          const fy = -top + bottom; // +y means stronger on top (canvas y downwards)
          const k = bi*16 + bj;
          FX[k]=fx; FY[k]=fy;
          const mag = Math.hypot(fx,fy);
          if (mag>mmax) mmax = mag;
        }
      }

      // 5) Draw quiver-like arrows over the heatmap
      // upscale factor from canvas pixel grid to CSS display size
      const cssScaleX = heat.clientWidth / heat.width;
      const cssScaleY = heat.clientHeight / heat.height;

      // We will draw on the same canvas using vector paths scaled by CSS size
      hctx.save();
      hctx.scale(cssScaleX, cssScaleY); // work in pixel-grid units
      hctx.lineWidth = 0.8; // will be scaled by CSS
      hctx.strokeStyle = 'white';

      const s = parseFloat(arrowScaleInput.value)||0.8;
      arrowScaleVal.textContent = s.toFixed(2) + '×';

      const centers = []; // 16x16 centers at 1.5:2:31.5
      for (let t=0;t<16;t++) centers[t] = 1.5 + 2*t;

      for (let bi=0; bi<16; bi++) {
        for (let bj=0; bj<16; bj++) {
          const k = bi*16 + bj;
          let fx = FX[k], fy = FY[k];
          if (mmax>0) { fx/=mmax; fy/=mmax; }
          // base position (in pixel grid of rotated image)
          const x0 = centers[bj];
          const y0 = centers[bi];
          const x1 = x0 + fx * (s*2.0); // scale a bit for visibility
          const y1 = y0 + fy * (s*2.0);

          // draw arrow line + head
          hctx.beginPath();
          hctx.moveTo(x0, y0);
          hctx.lineTo(x1, y1);
          hctx.stroke();
          // arrow head
          const dx = x1 - x0, dy = y1 - y0;
          const len = Math.hypot(dx,dy) || 1e-6;
          const ux = dx/len, uy = dy/len;
          const ah = 0.9;   // head length
          const aw = 0.6;   // head width
          // two side points
          const hx = x1 - ux*ah, hy = y1 - uy*ah;
          hctx.beginPath();
          hctx.moveTo(x1, y1);
          hctx.lineTo(hx + (-uy)*aw, hy + (ux)*aw);
          hctx.lineTo(hx - (-uy)*aw, hy - (ux)*aw);
          hctx.closePath();
          hctx.fillStyle = 'white';
          hctx.fill();
        }
      }
      hctx.restore();
    }

    // ==== Serial I/O ====
    async function connectSerial(){
      try{
        const baudRate = parseInt(baudInput.value)||12000000;
        port = await navigator.serial.requestPort();
        await port.open({ baudRate });
        keepReading = true;
        statusEl.textContent = `Connected @ ${baudRate}. Waiting for data...`;
        connectBtn.textContent = 'Disconnect';
        baudInput.disabled = true;
        readLoop();
      }catch(err){
        statusEl.textContent = 'Error: ' + err.message;
        console.error(err);
        await safeDisconnect();
      }
    }

    async function safeDisconnect(){
      keepReading = false;
      try{ if(reader){ await reader.cancel(); } }catch(e){}
      reader = null;
      try{ if(port){ await port.close(); } }catch(e){}
      port = null;
      statusEl.textContent = 'Status: Disconnected';
      connectBtn.textContent = 'Connect';
      baudInput.disabled = false;
    }

    async function readLoop(){
      if(!port?.readable) return;
      const td = new TextDecoderStream();
      const pipe = port.readable.pipeTo(td.writable);
      reader = td.readable.getReader();
      let buf = '';
      try{
        while(keepReading){
          const {value, done} = await reader.read();
          if(done) break;
          if(value){
            buf += value;
            let nl;
            while((nl = buf.indexOf('\n')) >= 0){
              const line = buf.slice(0,nl).trim();
              buf = buf.slice(nl+1);
              if(line) handleLine(line);
            }
          }
        }
      }catch(err){
        console.warn('Read error', err);
        statusEl.textContent = 'Read error: ' + err.message;
      }finally{
        await safeDisconnect();
      }
    }

    function handleLine(line){
      // Expect EXACTLY 1024 comma-separated numeric values (full frame)
      // e.g., "v1,v2,...,v1024" with optional whitespace
      const parts = line.split(',');
      if(parts.length < N){
        // ignore partial frames
        return;
      }
      let count = 0;
      for(let i=0;i<N;i++){
        const v = parseFloat(parts[i]);
        img[i] = Number.isFinite(v) ? v : 0;
        count++;
      }
      if(count===N){
        statusEl.textContent = 'Receiving data…';
        drawHeatAndVectors();
      }
    }

    // ==== Events ====
    connectBtn.addEventListener('click', () => {
      if(port) safeDisconnect(); else connectSerial();
    });
    thresInput.addEventListener('change', drawHeatAndVectors);
    clampMaxInput.addEventListener('change', drawHeatAndVectors);
    arrowScaleInput.addEventListener('input', drawHeatAndVectors);

    // Init first frame (blank)
    img.fill(0); drawHeatAndVectors();

    // Feature detection
    if(!('serial' in navigator)){
      statusEl.textContent = 'Web Serial API not supported. Use Chrome/Edge and enable experimental features if needed.';
      connectBtn.disabled = true; baudInput.disabled = true;
      alert('Web Serial API not supported on this browser. Try Chrome/Edge (desktop) with Web Serial enabled.');
    }
  </script>
</body>
</html>
